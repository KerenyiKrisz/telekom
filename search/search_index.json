{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs Yahoo! Bugidibuu! For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Welcome to MkDocs"},{"location":"#welcome-to-mkdocs","text":"Yahoo! Bugidibuu! For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"api/","text":"Application Programming Interface This page will have my API docs","title":"Application Programming Interface"},{"location":"api/#application-programming-interface","text":"This page will have my API docs","title":"Application Programming Interface"},{"location":"streamlit_input_best_practices/","text":"Streamlit Input Components Best Practices for Customer Churn Prediction Executive Summary For a customer churn prediction dashboard, the optimal approach combines semantic clarity (using component types that match the data type), cognitive load reduction (grouping related inputs), and business context (making predictions feel immediate and reliable). 1. Input Widgets by Data Type A. Continuous Numeric Data (Tenure, Charges) \u2705 RECOMMENDED: st.slider() for bounded ranges tenure = st.slider( \"Tenure (months)\", min_value=0, max_value=72, value=24, step=1, help=\"Years with company (0-6 years)\" ) Advantages for business dashboards: - Visual feedback : Users see the range context immediately - Prevents outliers : Hard boundaries prevent invalid inputs - Exploration friendly : Dragging encourages \"what-if\" scenarios - Mobile-friendly : Touch-friendly on tablets used by support teams Trade-offs: - Poor for entering precise values (hard to hit exact number) - Takes more screen space - For tenure, 72-month maximum is realistic business constraint \ud83d\udfe1 ALTERNATIVE: st.number_input() when precision matters monthly_charges = st.number_input( \"Monthly Charges ($)\", min_value=0.0, max_value=120.0, step=0.01, value=50.0, format=\"$%.2f\" ) When to use: - Customer services with precise billing (e.g., $65.43) - When users know exact value and entering is faster than sliding - For data import workflows Disadvantages for churn prediction: - Less intuitive for exploratory \"what-if\" analysis - Doesn't communicate range constraints visually - Higher cognitive load to understand valid ranges B. Boolean/Service Status Data (Tech Support, Online Security, etc.) \u2705 RECOMMENDED: st.toggle() for single binary service tech_support = st.toggle( \"Tech Support Active\", value=False, help=\"Customer has tech support subscription\" ) Advantages: - Immediate visual state : ON/OFF is crystal clear - Accessibility : Larger touch target than checkbox - Modern UX : Matches contemporary app patterns - Clean visual : Minimal screen clutter When to use: - Individual service toggles - Admin dashboards where on/off is primary concern - Forms with one boolean per row \ud83d\udfe1 ACCEPTABLE: st.checkbox() for multiple services tech_support = st.checkbox(\"Tech Support\", value=False) online_security = st.checkbox(\"Online Security\", value=True) phone_service = st.checkbox(\"Phone Service\", value=False) Advantages: - Traditional, universally understood - Good for multiple related booleans in close proximity - Works well in compact layouts Disadvantages: - Smaller visual state indicator than toggle - Feels dated in modern dashboards - Checkboxes grouped vertically can feel cluttered \u2705 RECOMMENDED for service categories: st.select_slider() or custom layout # Better: Present as readable service group with st.container(border=True): st.subheader(\"\ud83d\udcf1 Services\") col1, col2, col3 = st.columns(3) with col1: tech_support = st.toggle(\"Tech Support\") with col2: online_security = st.toggle(\"Online Security\") with col3: phone_service = st.toggle(\"Phone Service\") Why: - Visual grouping creates semantic meaning - Border/container distinguishes service section - Emoji + text provides business context - Horizontal layout reduces vertical scrolling C. Categorical Data (Contract Type, Internet Service, etc.) \u2705 RECOMMENDED: st.selectbox() for 3-6 options contract_type = st.selectbox( \"Contract Type\", options=[\"Month-to-month\", \"One year\", \"Two year\"], help=\"Current contract duration\" ) Advantages: - Compact : Only shows selected value until clicked - Mobile-friendly : Dropdown is touch-friendly - Semantic : Clear that this is a choice - Predictable : Single column layout When to use: - 3-6 clearly different options - Dropdown is hidden by default (saves space) - Options have natural hierarchy or ordering \ud83d\udfe1 ALTERNATIVE: st.radio() for obvious choices internet_service = st.radio( \"Internet Service Type\", options=[\"DSL\", \"Fiber Optic\", \"None\"], horizontal=True ) Advantages: - All options visible without clicking - Cannot miss an option - Clear at-a-glance what's available Disadvantages: - Takes more space (not all options fit horizontally on mobile) - Radio buttons feel dated in modern Streamlit - Better reserved for important decisions \u274c AVOID for churn dashboards: st.multiselect() for single choice # DON'T DO THIS services = st.multiselect(\"Select services\", options=[...]) Why avoid: - Confuses users (they expect to select multiple) - Adds complexity for single-choice scenarios - Takes up space 2. Form Patterns: Individual vs. Grouped Inputs \u2705 RECOMMENDED: st.form() for customer data entry with st.form(\"customer_input_form\"): st.subheader(\"\ud83d\udccb Customer Information\") col1, col2 = st.columns(2) with col1: tenure = st.slider(\"Tenure (months)\", 0, 72, 24) monthly = st.number_input(\"Monthly Charges ($)\", 0.0, 120.0, 50.0) with col2: contract = st.selectbox(\"Contract Type\", [\"Month-to-month\", \"One year\", \"Two year\"]) internet = st.selectbox(\"Internet Service\", [\"DSL\", \"Fiber Optic\", \"No\"]) services_header = st.subheader(\"\ud83d\udcf1 Services\") col1, col2, col3 = st.columns(3) with col1: tech_support = st.toggle(\"Tech Support\", value=False) with col2: online_security = st.toggle(\"Online Security\", value=False) with col3: backup_service = st.toggle(\"Backup Service\", value=False) submitted = st.form_submit_button(\"\ud83d\udd2e Predict Churn Risk\") if submitted: # Make single API call with all data prediction = fetch_prediction({ \"tenure\": tenure, \"monthly\": monthly, \"contract\": contract, \"internet\": internet, \"tech_support\": tech_support, \"online_security\": online_security, \"backup_service\": backup_service }) Advantages: - Single API call : Reduces latency and server load - Atomic transactions : All-or-nothing data consistency - User expectation : \"Submit\" button signals form-like behavior - Performance : Streamlit re-runs only on submit, not per input change Business dashboard benefits: - Support teams feel confident they've entered complete data - No premature predictions while they're still filling form - Protects API from excessive calls - Better for batch processing customer lists \ud83d\udfe1 ALTERNATIVE: Reactive inputs (no form) # Individual inputs without form (auto-predict on each change) tenure = st.slider(\"Tenure (months)\", 0, 72, 24) monthly = st.number_input(\"Monthly Charges ($)\", 0.0, 120.0, 50.0) tech_support = st.toggle(\"Tech Support\", value=False) # Prediction happens immediately on any change prediction = fetch_prediction({...}) When to use: - Exploratory dashboards where \"what-if\" is the goal - Lightweight predictions with fast API response - Single customer analysis (not batch processing) Disadvantages for business use: - Multiple API calls per user interaction - Can feel \"laggy\" with slow API - Higher server load - Users feel pressured by real-time feedback 3. Recommended Component Mapping for Telco Churn Data Customer Demographics Data Type Widget Reasoning Tenure Continuous (0-72 mo) st.slider() Bounded range, natural max is 72mo Monthly Charges Continuous ($) st.slider() Range-based; most churn patterns fit $18-120 Total Charges Continuous ($) Calculated (tenure \u00d7 monthly) Derived, show only Age Continuous (18-80) st.slider() If available; clear age range context Service Status (Booleans) Data Widget Alternative Tech Support st.toggle() st.checkbox() Online Security st.toggle() st.checkbox() Phone Service st.toggle() st.radio(horizontal=True) Internet Service st.selectbox() st.radio() Backup Service st.toggle() Grouped checkbox Contract & Billing Data Type Widget Contract Type Categorical st.selectbox() Internet Service Categorical st.selectbox() Payment Method Categorical st.selectbox() Paperless Billing Boolean st.toggle() 4. Layout Patterns for Business Dashboards \u2705 RECOMMENDED: Sectioned layout with clear visual hierarchy st.title(\"\ud83d\udcca Telco Churn Prediction\") # Section 1: Core Demographics with st.container(border=True): st.subheader(\"\ud83d\udc64 Customer Profile\") col1, col2, col3 = st.columns(3) with col1: tenure = st.slider(\"Tenure\", 0, 72, 24) with col2: monthly = st.slider(\"Monthly Charges ($)\", 18, 120, 50) with col3: total_charges = tenure * monthly st.metric(\"Total Charges\", f\"${total_charges:.2f}\") # Section 2: Services with st.container(border=True): st.subheader(\"\ud83d\udcf1 Subscribed Services\") col1, col2, col3 = st.columns(3) with col1: tech_support = st.toggle(\"Tech Support\") with col2: online_security = st.toggle(\"Online Security\") with col3: phone = st.toggle(\"Phone Service\") # Section 3: Contract Details with st.container(border=True): st.subheader(\"\ud83d\udccb Account Details\") col1, col2 = st.columns(2) with col1: contract = st.selectbox(\"Contract Type\", [\"Month-to-month\", \"One year\", \"Two year\"]) with col2: internet = st.selectbox(\"Internet Service\", [\"DSL\", \"Fiber Optic\", \"No\"]) # Prediction Section col1, col2, col3 = st.columns([1, 2, 1]) with col2: if st.button(\"\ud83d\udd2e Predict Churn Risk\", use_container_width=True): prediction = fetch_prediction({...}) # Display results Why this works: - Visual hierarchy reduces cognitive load - Containers group related inputs - Emoji + text provides semantic meaning - Call-to-action button is prominent and centered 5. Input Validation & Error Handling \u2705 RECOMMENDED: Validate in form before prediction with st.form(\"prediction_form\"): tenure = st.slider(\"Tenure (months)\", 0, 72) monthly = st.number_input(\"Monthly ($)\", 0.0, 150.0) contract = st.selectbox(\"Contract\", [\"Month-to-month\", \"One year\", \"Two year\"]) submitted = st.form_submit_button(\"Predict\") if submitted: # Client-side validation if tenure < 0 or monthly < 0: st.error(\"\u274c Invalid input values\") elif tenure == 0 and monthly == 0: st.warning(\"\u26a0\ufe0f New customer with no charges - unusual but valid\") else: try: prediction = fetch_prediction({ \"tenure\": tenure, \"monthly\": monthly, \"contract\": contract }) st.success(f\"\u2705 Churn probability: {prediction:.1%}\") except requests.RequestException as e: st.error(f\"API Error: {str(e)}\") Best practices: - Sliders/selectboxes eliminate most invalid input automatically - Form submission validates before API call - Clear error messages guide users - Unexpected inputs (like new customers with $0) get warnings, not errors 6. Mobile & Accessibility Considerations \u2705 Optimize for support team tablets # Use responsive columns col1, col2 = st.columns([1, 1]) # Equal width # Avoid horizontal radio with >3 options internet = st.selectbox(\"Internet\", [\"DSL\", \"Fiber\", \"No\", \"Satellite\"]) # Use large touch targets tech_support = st.toggle(\"Tech Support\") # Larger than checkbox # Add help text for all inputs tenure = st.slider(\"Tenure (months)\", help=\"How long customer has been with us\") # Use horizontal=True for max 3-4 options gender = st.radio(\"Gender\", [\"Male\", \"Female\"], horizontal=True) # Test on mobile before deployment st.write(\"\ud83d\udc49 *Designed for tablet & desktop*\") 7. Performance Optimization \u2705 Use @st.cache_data for static options @st.cache_data def get_contract_options(): return [\"Month-to-month\", \"One year\", \"Two year\"] contract = st.selectbox(\"Contract Type\", get_contract_options()) \u2705 Debounce number inputs with forms with st.form(\"input_form\"): monthly = st.number_input(\"Monthly Charges\", step=0.01) if st.form_submit_button(\"Calculate\"): # Single API call, not per keystroke result = predict(monthly) 8. Recommended Implementation for Your Dashboard Current Issues: \u274c Tenure as selectbox is poor UX (requires scrolling to find value) \u2705 Monthly charges as number_input is appropriate \u2705 Tech support as checkbox works but toggle would be better \u274c Missing form - API is called during re-render Improved Implementation: import streamlit as st import requests st.set_page_config(page_title=\"Telco Churn Predictor\", page_icon=\"\ud83d\udcca\", layout=\"wide\") st.title(\"\ud83d\udcca Telco Churn Prediction Dashboard\") st.write(\"Predict customer churn risk based on their profile and services.\") st.divider() # Form groups inputs and prevents excessive API calls with st.form(\"churn_prediction_form\"): st.subheader(\"\ud83d\udccb Customer Information\") col1, col2, col3 = st.columns(3) with col1: tenure = st.slider( \"Tenure (months)\", min_value=0, max_value=72, value=24, step=1, help=\"How long the customer has been with company (0-72 months)\" ) with col2: monthly = st.slider( \"Monthly Charges ($)\", min_value=18.0, max_value=120.0, value=50.0, step=1.0, help=\"Monthly service charges ($18-$120 typical range)\" ) with col3: # Calculate and display total charges total_charges = tenure * monthly st.metric(\"Total Charges\", f\"${total_charges:,.0f}\") # Services section st.subheader(\"\ud83d\udcf1 Subscribed Services\") col1, col2, col3, col4 = st.columns(4) with col1: tech_support = st.toggle( \"Tech Support\", value=False, help=\"Customer has tech support subscription\" ) with col2: online_security = st.toggle( \"Online Security\", value=False, help=\"Customer has online security subscription\" ) with col3: phone_service = st.toggle( \"Phone Service\", value=False, help=\"Customer has phone service\" ) with col4: backup_service = st.toggle( \"Backup Service\", value=False, help=\"Customer has backup service\" ) # Contract section st.subheader(\"\ud83d\udccb Account Details\") col1, col2, col3 = st.columns(3) with col1: contract = st.selectbox( \"Contract Type\", [\"Month-to-month\", \"One year\", \"Two year\"], help=\"Duration of customer contract\" ) with col2: internet = st.selectbox( \"Internet Service\", [\"DSL\", \"Fiber Optic\", \"No\"], help=\"Type of internet service\" ) with col3: payment_method = st.selectbox( \"Payment Method\", [\"Electronic check\", \"Mailed check\", \"Bank transfer\", \"Credit card\"], help=\"How customer pays their bill\" ) # Submit button col1, col2, col3 = st.columns([1, 2, 1]) with col2: submitted = st.form_submit_button( \"\ud83d\udd2e Predict Churn Risk\", use_container_width=True, type=\"primary\" ) # Only process prediction after form submission if submitted: payload = { \"tenure\": float(tenure), \"monthly\": float(monthly), \"techsupport\": float(tech_support), \"onlinesecurity\": float(online_security), \"phoneservice\": float(phone_service), \"backupservice\": float(backup_service), \"contract\": contract, \"internet\": internet, \"payment_method\": payment_method, } try: response = requests.post( \"http://127.0.0.1:8000/predict\", json=payload, timeout=5 ) response.raise_for_status() data = response.json() prediction = data.get(\"prediction\", 0) churn_percentage = prediction * 100 st.divider() st.subheader(\"\ud83c\udfaf Prediction Results\") # Risk level determination if prediction < 0.3: color = \"green\" risk_level = \"Low Risk\" elif prediction < 0.6: color = \"orange\" risk_level = \"Medium Risk\" else: color = \"red\" risk_level = \"High Risk\" col1, col2, col3 = st.columns(3) with col1: st.metric(\"Churn Probability\", f\"{churn_percentage:.1f}%\") with col2: st.metric(\"Risk Level\", risk_level) with col3: st.metric(\"Tenure (months)\", int(tenure)) # Progress bar st.progress( min(prediction, 1.0), text=f\"Churn Risk: {churn_percentage:.1f}%\" ) # Insights st.divider() st.subheader(\"\ud83d\udca1 Insights & Recommendations\") if prediction < 0.3: st.success( f\"\u2705 **Low Churn Risk** ({churn_percentage:.1f}%)\\n\\n\" f\"This customer appears satisfied. Consider offering loyalty programs \" f\"to maintain retention and potentially upsell premium services.\" ) elif prediction < 0.6: st.warning( f\"\u26a0\ufe0f **Medium Churn Risk** ({churn_percentage:.1f}%)\\n\\n\" f\"Review their account and consider offering service upgrades, discounts, \" f\"or improved support to reduce churn likelihood.\" ) else: st.error( f\"\ud83d\udea8 **High Churn Risk** ({churn_percentage:.1f}%)\\n\\n\" f\"Immediate intervention recommended! Contact customer to understand concerns \" f\"and offer retention incentives.\" ) # Detailed information with st.expander(\"\ud83d\udcca Detailed Information\"): col1, col2 = st.columns(2) with col1: st.write(\"**Input Parameters:**\") st.write(f\"- Tenure: {tenure} months\") st.write(f\"- Monthly Charges: ${monthly:.2f}\") st.write(f\"- Total Charges: ${total_charges:,.2f}\") st.write(f\"- Tech Support: {'\u2705 Yes' if tech_support else '\u274c No'}\") st.write(f\"- Online Security: {'\u2705 Yes' if online_security else '\u274c No'}\") st.write(f\"- Phone Service: {'\u2705 Yes' if phone_service else '\u274c No'}\") st.write(f\"- Backup Service: {'\u2705 Yes' if backup_service else '\u274c No'}\") st.write(f\"- Contract Type: {contract}\") st.write(f\"- Internet Service: {internet}\") st.write(f\"- Payment Method: {payment_method}\") with col2: st.write(\"**Model Output:**\") st.json(data) except requests.RequestException as e: st.error(f\"\u274c Error calling API: {e}\") st.info(\"Make sure the API server is running on http://127.0.0.1:8000\") except Exception as e: st.error(f\"\u274c Unexpected error: {e}\") 9. Summary Table: Component Recommendations Scenario Widget Reasoning Continuous, bounded (tenure, age) st.slider() Visual range context, prevents outliers Precise decimal (billing) st.slider() with step Slider better than number_input for business Boolean, single st.toggle() Modern, clear ON/OFF state Boolean, multiple related st.toggle() \u00d7 N Group in columns with container border Categorical, 3-6 options st.selectbox() Compact, mobile-friendly, clear choices Categorical, obvious choice st.radio() with horizontal=True Only if \u22643 options and always visible matters Data entry workflow st.form() Single submit, fewer API calls, better UX Exploratory analysis Individual inputs Real-time feedback for what-if scenarios 10. Key Takeaways for Your Dashboard \u2705 DO: - Use st.slider() for tenure (bounded, intuitive) - Use st.toggle() for service booleans (modern, clear) - Use st.form() to batch inputs (one API call, atomic) - Add help text to all inputs (context for support teams) - Use st.container(border=True) to group related inputs - Test on tablet (your users' primary device) \u274c DON'T: - Use st.selectbox() for tenure (users have to scroll) - Mix st.checkbox() and st.toggle() (inconsistent) - Process inputs outside forms (causes excessive API calls) - Use numbers without units ($ for money, months for time) - Forget accessibility (tooltips, clear labels, large touch targets)","title":"Streamlit Input Components Best Practices for Customer Churn Prediction"},{"location":"streamlit_input_best_practices/#streamlit-input-components-best-practices-for-customer-churn-prediction","text":"","title":"Streamlit Input Components Best Practices for Customer Churn Prediction"},{"location":"streamlit_input_best_practices/#executive-summary","text":"For a customer churn prediction dashboard, the optimal approach combines semantic clarity (using component types that match the data type), cognitive load reduction (grouping related inputs), and business context (making predictions feel immediate and reliable).","title":"Executive Summary"},{"location":"streamlit_input_best_practices/#1-input-widgets-by-data-type","text":"","title":"1. Input Widgets by Data Type"},{"location":"streamlit_input_best_practices/#a-continuous-numeric-data-tenure-charges","text":"","title":"A. Continuous Numeric Data (Tenure, Charges)"},{"location":"streamlit_input_best_practices/#recommended-stslider-for-bounded-ranges","text":"tenure = st.slider( \"Tenure (months)\", min_value=0, max_value=72, value=24, step=1, help=\"Years with company (0-6 years)\" ) Advantages for business dashboards: - Visual feedback : Users see the range context immediately - Prevents outliers : Hard boundaries prevent invalid inputs - Exploration friendly : Dragging encourages \"what-if\" scenarios - Mobile-friendly : Touch-friendly on tablets used by support teams Trade-offs: - Poor for entering precise values (hard to hit exact number) - Takes more screen space - For tenure, 72-month maximum is realistic business constraint","title":"\u2705 RECOMMENDED: st.slider() for bounded ranges"},{"location":"streamlit_input_best_practices/#alternative-stnumber_input-when-precision-matters","text":"monthly_charges = st.number_input( \"Monthly Charges ($)\", min_value=0.0, max_value=120.0, step=0.01, value=50.0, format=\"$%.2f\" ) When to use: - Customer services with precise billing (e.g., $65.43) - When users know exact value and entering is faster than sliding - For data import workflows Disadvantages for churn prediction: - Less intuitive for exploratory \"what-if\" analysis - Doesn't communicate range constraints visually - Higher cognitive load to understand valid ranges","title":"\ud83d\udfe1 ALTERNATIVE: st.number_input() when precision matters"},{"location":"streamlit_input_best_practices/#b-booleanservice-status-data-tech-support-online-security-etc","text":"","title":"B. Boolean/Service Status Data (Tech Support, Online Security, etc.)"},{"location":"streamlit_input_best_practices/#recommended-sttoggle-for-single-binary-service","text":"tech_support = st.toggle( \"Tech Support Active\", value=False, help=\"Customer has tech support subscription\" ) Advantages: - Immediate visual state : ON/OFF is crystal clear - Accessibility : Larger touch target than checkbox - Modern UX : Matches contemporary app patterns - Clean visual : Minimal screen clutter When to use: - Individual service toggles - Admin dashboards where on/off is primary concern - Forms with one boolean per row","title":"\u2705 RECOMMENDED: st.toggle() for single binary service"},{"location":"streamlit_input_best_practices/#acceptable-stcheckbox-for-multiple-services","text":"tech_support = st.checkbox(\"Tech Support\", value=False) online_security = st.checkbox(\"Online Security\", value=True) phone_service = st.checkbox(\"Phone Service\", value=False) Advantages: - Traditional, universally understood - Good for multiple related booleans in close proximity - Works well in compact layouts Disadvantages: - Smaller visual state indicator than toggle - Feels dated in modern dashboards - Checkboxes grouped vertically can feel cluttered","title":"\ud83d\udfe1 ACCEPTABLE: st.checkbox() for multiple services"},{"location":"streamlit_input_best_practices/#recommended-for-service-categories-stselect_slider-or-custom-layout","text":"# Better: Present as readable service group with st.container(border=True): st.subheader(\"\ud83d\udcf1 Services\") col1, col2, col3 = st.columns(3) with col1: tech_support = st.toggle(\"Tech Support\") with col2: online_security = st.toggle(\"Online Security\") with col3: phone_service = st.toggle(\"Phone Service\") Why: - Visual grouping creates semantic meaning - Border/container distinguishes service section - Emoji + text provides business context - Horizontal layout reduces vertical scrolling","title":"\u2705 RECOMMENDED for service categories: st.select_slider() or custom layout"},{"location":"streamlit_input_best_practices/#c-categorical-data-contract-type-internet-service-etc","text":"","title":"C. Categorical Data (Contract Type, Internet Service, etc.)"},{"location":"streamlit_input_best_practices/#recommended-stselectbox-for-3-6-options","text":"contract_type = st.selectbox( \"Contract Type\", options=[\"Month-to-month\", \"One year\", \"Two year\"], help=\"Current contract duration\" ) Advantages: - Compact : Only shows selected value until clicked - Mobile-friendly : Dropdown is touch-friendly - Semantic : Clear that this is a choice - Predictable : Single column layout When to use: - 3-6 clearly different options - Dropdown is hidden by default (saves space) - Options have natural hierarchy or ordering","title":"\u2705 RECOMMENDED: st.selectbox() for 3-6 options"},{"location":"streamlit_input_best_practices/#alternative-stradio-for-obvious-choices","text":"internet_service = st.radio( \"Internet Service Type\", options=[\"DSL\", \"Fiber Optic\", \"None\"], horizontal=True ) Advantages: - All options visible without clicking - Cannot miss an option - Clear at-a-glance what's available Disadvantages: - Takes more space (not all options fit horizontally on mobile) - Radio buttons feel dated in modern Streamlit - Better reserved for important decisions","title":"\ud83d\udfe1 ALTERNATIVE: st.radio() for obvious choices"},{"location":"streamlit_input_best_practices/#avoid-for-churn-dashboards-stmultiselect-for-single-choice","text":"# DON'T DO THIS services = st.multiselect(\"Select services\", options=[...]) Why avoid: - Confuses users (they expect to select multiple) - Adds complexity for single-choice scenarios - Takes up space","title":"\u274c AVOID for churn dashboards: st.multiselect() for single choice"},{"location":"streamlit_input_best_practices/#2-form-patterns-individual-vs-grouped-inputs","text":"","title":"2. Form Patterns: Individual vs. Grouped Inputs"},{"location":"streamlit_input_best_practices/#recommended-stform-for-customer-data-entry","text":"with st.form(\"customer_input_form\"): st.subheader(\"\ud83d\udccb Customer Information\") col1, col2 = st.columns(2) with col1: tenure = st.slider(\"Tenure (months)\", 0, 72, 24) monthly = st.number_input(\"Monthly Charges ($)\", 0.0, 120.0, 50.0) with col2: contract = st.selectbox(\"Contract Type\", [\"Month-to-month\", \"One year\", \"Two year\"]) internet = st.selectbox(\"Internet Service\", [\"DSL\", \"Fiber Optic\", \"No\"]) services_header = st.subheader(\"\ud83d\udcf1 Services\") col1, col2, col3 = st.columns(3) with col1: tech_support = st.toggle(\"Tech Support\", value=False) with col2: online_security = st.toggle(\"Online Security\", value=False) with col3: backup_service = st.toggle(\"Backup Service\", value=False) submitted = st.form_submit_button(\"\ud83d\udd2e Predict Churn Risk\") if submitted: # Make single API call with all data prediction = fetch_prediction({ \"tenure\": tenure, \"monthly\": monthly, \"contract\": contract, \"internet\": internet, \"tech_support\": tech_support, \"online_security\": online_security, \"backup_service\": backup_service }) Advantages: - Single API call : Reduces latency and server load - Atomic transactions : All-or-nothing data consistency - User expectation : \"Submit\" button signals form-like behavior - Performance : Streamlit re-runs only on submit, not per input change Business dashboard benefits: - Support teams feel confident they've entered complete data - No premature predictions while they're still filling form - Protects API from excessive calls - Better for batch processing customer lists","title":"\u2705 RECOMMENDED: st.form() for customer data entry"},{"location":"streamlit_input_best_practices/#alternative-reactive-inputs-no-form","text":"# Individual inputs without form (auto-predict on each change) tenure = st.slider(\"Tenure (months)\", 0, 72, 24) monthly = st.number_input(\"Monthly Charges ($)\", 0.0, 120.0, 50.0) tech_support = st.toggle(\"Tech Support\", value=False) # Prediction happens immediately on any change prediction = fetch_prediction({...}) When to use: - Exploratory dashboards where \"what-if\" is the goal - Lightweight predictions with fast API response - Single customer analysis (not batch processing) Disadvantages for business use: - Multiple API calls per user interaction - Can feel \"laggy\" with slow API - Higher server load - Users feel pressured by real-time feedback","title":"\ud83d\udfe1 ALTERNATIVE: Reactive inputs (no form)"},{"location":"streamlit_input_best_practices/#3-recommended-component-mapping-for-telco-churn-data","text":"","title":"3. Recommended Component Mapping for Telco Churn Data"},{"location":"streamlit_input_best_practices/#customer-demographics","text":"Data Type Widget Reasoning Tenure Continuous (0-72 mo) st.slider() Bounded range, natural max is 72mo Monthly Charges Continuous ($) st.slider() Range-based; most churn patterns fit $18-120 Total Charges Continuous ($) Calculated (tenure \u00d7 monthly) Derived, show only Age Continuous (18-80) st.slider() If available; clear age range context","title":"Customer Demographics"},{"location":"streamlit_input_best_practices/#service-status-booleans","text":"Data Widget Alternative Tech Support st.toggle() st.checkbox() Online Security st.toggle() st.checkbox() Phone Service st.toggle() st.radio(horizontal=True) Internet Service st.selectbox() st.radio() Backup Service st.toggle() Grouped checkbox","title":"Service Status (Booleans)"},{"location":"streamlit_input_best_practices/#contract-billing","text":"Data Type Widget Contract Type Categorical st.selectbox() Internet Service Categorical st.selectbox() Payment Method Categorical st.selectbox() Paperless Billing Boolean st.toggle()","title":"Contract &amp; Billing"},{"location":"streamlit_input_best_practices/#4-layout-patterns-for-business-dashboards","text":"","title":"4. Layout Patterns for Business Dashboards"},{"location":"streamlit_input_best_practices/#recommended-sectioned-layout-with-clear-visual-hierarchy","text":"st.title(\"\ud83d\udcca Telco Churn Prediction\") # Section 1: Core Demographics with st.container(border=True): st.subheader(\"\ud83d\udc64 Customer Profile\") col1, col2, col3 = st.columns(3) with col1: tenure = st.slider(\"Tenure\", 0, 72, 24) with col2: monthly = st.slider(\"Monthly Charges ($)\", 18, 120, 50) with col3: total_charges = tenure * monthly st.metric(\"Total Charges\", f\"${total_charges:.2f}\") # Section 2: Services with st.container(border=True): st.subheader(\"\ud83d\udcf1 Subscribed Services\") col1, col2, col3 = st.columns(3) with col1: tech_support = st.toggle(\"Tech Support\") with col2: online_security = st.toggle(\"Online Security\") with col3: phone = st.toggle(\"Phone Service\") # Section 3: Contract Details with st.container(border=True): st.subheader(\"\ud83d\udccb Account Details\") col1, col2 = st.columns(2) with col1: contract = st.selectbox(\"Contract Type\", [\"Month-to-month\", \"One year\", \"Two year\"]) with col2: internet = st.selectbox(\"Internet Service\", [\"DSL\", \"Fiber Optic\", \"No\"]) # Prediction Section col1, col2, col3 = st.columns([1, 2, 1]) with col2: if st.button(\"\ud83d\udd2e Predict Churn Risk\", use_container_width=True): prediction = fetch_prediction({...}) # Display results Why this works: - Visual hierarchy reduces cognitive load - Containers group related inputs - Emoji + text provides semantic meaning - Call-to-action button is prominent and centered","title":"\u2705 RECOMMENDED: Sectioned layout with clear visual hierarchy"},{"location":"streamlit_input_best_practices/#5-input-validation-error-handling","text":"","title":"5. Input Validation &amp; Error Handling"},{"location":"streamlit_input_best_practices/#recommended-validate-in-form-before-prediction","text":"with st.form(\"prediction_form\"): tenure = st.slider(\"Tenure (months)\", 0, 72) monthly = st.number_input(\"Monthly ($)\", 0.0, 150.0) contract = st.selectbox(\"Contract\", [\"Month-to-month\", \"One year\", \"Two year\"]) submitted = st.form_submit_button(\"Predict\") if submitted: # Client-side validation if tenure < 0 or monthly < 0: st.error(\"\u274c Invalid input values\") elif tenure == 0 and monthly == 0: st.warning(\"\u26a0\ufe0f New customer with no charges - unusual but valid\") else: try: prediction = fetch_prediction({ \"tenure\": tenure, \"monthly\": monthly, \"contract\": contract }) st.success(f\"\u2705 Churn probability: {prediction:.1%}\") except requests.RequestException as e: st.error(f\"API Error: {str(e)}\") Best practices: - Sliders/selectboxes eliminate most invalid input automatically - Form submission validates before API call - Clear error messages guide users - Unexpected inputs (like new customers with $0) get warnings, not errors","title":"\u2705 RECOMMENDED: Validate in form before prediction"},{"location":"streamlit_input_best_practices/#6-mobile-accessibility-considerations","text":"","title":"6. Mobile &amp; Accessibility Considerations"},{"location":"streamlit_input_best_practices/#optimize-for-support-team-tablets","text":"# Use responsive columns col1, col2 = st.columns([1, 1]) # Equal width # Avoid horizontal radio with >3 options internet = st.selectbox(\"Internet\", [\"DSL\", \"Fiber\", \"No\", \"Satellite\"]) # Use large touch targets tech_support = st.toggle(\"Tech Support\") # Larger than checkbox # Add help text for all inputs tenure = st.slider(\"Tenure (months)\", help=\"How long customer has been with us\") # Use horizontal=True for max 3-4 options gender = st.radio(\"Gender\", [\"Male\", \"Female\"], horizontal=True) # Test on mobile before deployment st.write(\"\ud83d\udc49 *Designed for tablet & desktop*\")","title":"\u2705 Optimize for support team tablets"},{"location":"streamlit_input_best_practices/#7-performance-optimization","text":"","title":"7. Performance Optimization"},{"location":"streamlit_input_best_practices/#use-stcache_data-for-static-options","text":"@st.cache_data def get_contract_options(): return [\"Month-to-month\", \"One year\", \"Two year\"] contract = st.selectbox(\"Contract Type\", get_contract_options())","title":"\u2705 Use @st.cache_data for static options"},{"location":"streamlit_input_best_practices/#debounce-number-inputs-with-forms","text":"with st.form(\"input_form\"): monthly = st.number_input(\"Monthly Charges\", step=0.01) if st.form_submit_button(\"Calculate\"): # Single API call, not per keystroke result = predict(monthly)","title":"\u2705 Debounce number inputs with forms"},{"location":"streamlit_input_best_practices/#8-recommended-implementation-for-your-dashboard","text":"","title":"8. Recommended Implementation for Your Dashboard"},{"location":"streamlit_input_best_practices/#current-issues","text":"\u274c Tenure as selectbox is poor UX (requires scrolling to find value) \u2705 Monthly charges as number_input is appropriate \u2705 Tech support as checkbox works but toggle would be better \u274c Missing form - API is called during re-render","title":"Current Issues:"},{"location":"streamlit_input_best_practices/#improved-implementation","text":"import streamlit as st import requests st.set_page_config(page_title=\"Telco Churn Predictor\", page_icon=\"\ud83d\udcca\", layout=\"wide\") st.title(\"\ud83d\udcca Telco Churn Prediction Dashboard\") st.write(\"Predict customer churn risk based on their profile and services.\") st.divider() # Form groups inputs and prevents excessive API calls with st.form(\"churn_prediction_form\"): st.subheader(\"\ud83d\udccb Customer Information\") col1, col2, col3 = st.columns(3) with col1: tenure = st.slider( \"Tenure (months)\", min_value=0, max_value=72, value=24, step=1, help=\"How long the customer has been with company (0-72 months)\" ) with col2: monthly = st.slider( \"Monthly Charges ($)\", min_value=18.0, max_value=120.0, value=50.0, step=1.0, help=\"Monthly service charges ($18-$120 typical range)\" ) with col3: # Calculate and display total charges total_charges = tenure * monthly st.metric(\"Total Charges\", f\"${total_charges:,.0f}\") # Services section st.subheader(\"\ud83d\udcf1 Subscribed Services\") col1, col2, col3, col4 = st.columns(4) with col1: tech_support = st.toggle( \"Tech Support\", value=False, help=\"Customer has tech support subscription\" ) with col2: online_security = st.toggle( \"Online Security\", value=False, help=\"Customer has online security subscription\" ) with col3: phone_service = st.toggle( \"Phone Service\", value=False, help=\"Customer has phone service\" ) with col4: backup_service = st.toggle( \"Backup Service\", value=False, help=\"Customer has backup service\" ) # Contract section st.subheader(\"\ud83d\udccb Account Details\") col1, col2, col3 = st.columns(3) with col1: contract = st.selectbox( \"Contract Type\", [\"Month-to-month\", \"One year\", \"Two year\"], help=\"Duration of customer contract\" ) with col2: internet = st.selectbox( \"Internet Service\", [\"DSL\", \"Fiber Optic\", \"No\"], help=\"Type of internet service\" ) with col3: payment_method = st.selectbox( \"Payment Method\", [\"Electronic check\", \"Mailed check\", \"Bank transfer\", \"Credit card\"], help=\"How customer pays their bill\" ) # Submit button col1, col2, col3 = st.columns([1, 2, 1]) with col2: submitted = st.form_submit_button( \"\ud83d\udd2e Predict Churn Risk\", use_container_width=True, type=\"primary\" ) # Only process prediction after form submission if submitted: payload = { \"tenure\": float(tenure), \"monthly\": float(monthly), \"techsupport\": float(tech_support), \"onlinesecurity\": float(online_security), \"phoneservice\": float(phone_service), \"backupservice\": float(backup_service), \"contract\": contract, \"internet\": internet, \"payment_method\": payment_method, } try: response = requests.post( \"http://127.0.0.1:8000/predict\", json=payload, timeout=5 ) response.raise_for_status() data = response.json() prediction = data.get(\"prediction\", 0) churn_percentage = prediction * 100 st.divider() st.subheader(\"\ud83c\udfaf Prediction Results\") # Risk level determination if prediction < 0.3: color = \"green\" risk_level = \"Low Risk\" elif prediction < 0.6: color = \"orange\" risk_level = \"Medium Risk\" else: color = \"red\" risk_level = \"High Risk\" col1, col2, col3 = st.columns(3) with col1: st.metric(\"Churn Probability\", f\"{churn_percentage:.1f}%\") with col2: st.metric(\"Risk Level\", risk_level) with col3: st.metric(\"Tenure (months)\", int(tenure)) # Progress bar st.progress( min(prediction, 1.0), text=f\"Churn Risk: {churn_percentage:.1f}%\" ) # Insights st.divider() st.subheader(\"\ud83d\udca1 Insights & Recommendations\") if prediction < 0.3: st.success( f\"\u2705 **Low Churn Risk** ({churn_percentage:.1f}%)\\n\\n\" f\"This customer appears satisfied. Consider offering loyalty programs \" f\"to maintain retention and potentially upsell premium services.\" ) elif prediction < 0.6: st.warning( f\"\u26a0\ufe0f **Medium Churn Risk** ({churn_percentage:.1f}%)\\n\\n\" f\"Review their account and consider offering service upgrades, discounts, \" f\"or improved support to reduce churn likelihood.\" ) else: st.error( f\"\ud83d\udea8 **High Churn Risk** ({churn_percentage:.1f}%)\\n\\n\" f\"Immediate intervention recommended! Contact customer to understand concerns \" f\"and offer retention incentives.\" ) # Detailed information with st.expander(\"\ud83d\udcca Detailed Information\"): col1, col2 = st.columns(2) with col1: st.write(\"**Input Parameters:**\") st.write(f\"- Tenure: {tenure} months\") st.write(f\"- Monthly Charges: ${monthly:.2f}\") st.write(f\"- Total Charges: ${total_charges:,.2f}\") st.write(f\"- Tech Support: {'\u2705 Yes' if tech_support else '\u274c No'}\") st.write(f\"- Online Security: {'\u2705 Yes' if online_security else '\u274c No'}\") st.write(f\"- Phone Service: {'\u2705 Yes' if phone_service else '\u274c No'}\") st.write(f\"- Backup Service: {'\u2705 Yes' if backup_service else '\u274c No'}\") st.write(f\"- Contract Type: {contract}\") st.write(f\"- Internet Service: {internet}\") st.write(f\"- Payment Method: {payment_method}\") with col2: st.write(\"**Model Output:**\") st.json(data) except requests.RequestException as e: st.error(f\"\u274c Error calling API: {e}\") st.info(\"Make sure the API server is running on http://127.0.0.1:8000\") except Exception as e: st.error(f\"\u274c Unexpected error: {e}\")","title":"Improved Implementation:"},{"location":"streamlit_input_best_practices/#9-summary-table-component-recommendations","text":"Scenario Widget Reasoning Continuous, bounded (tenure, age) st.slider() Visual range context, prevents outliers Precise decimal (billing) st.slider() with step Slider better than number_input for business Boolean, single st.toggle() Modern, clear ON/OFF state Boolean, multiple related st.toggle() \u00d7 N Group in columns with container border Categorical, 3-6 options st.selectbox() Compact, mobile-friendly, clear choices Categorical, obvious choice st.radio() with horizontal=True Only if \u22643 options and always visible matters Data entry workflow st.form() Single submit, fewer API calls, better UX Exploratory analysis Individual inputs Real-time feedback for what-if scenarios","title":"9. Summary Table: Component Recommendations"},{"location":"streamlit_input_best_practices/#10-key-takeaways-for-your-dashboard","text":"\u2705 DO: - Use st.slider() for tenure (bounded, intuitive) - Use st.toggle() for service booleans (modern, clear) - Use st.form() to batch inputs (one API call, atomic) - Add help text to all inputs (context for support teams) - Use st.container(border=True) to group related inputs - Test on tablet (your users' primary device) \u274c DON'T: - Use st.selectbox() for tenure (users have to scroll) - Mix st.checkbox() and st.toggle() (inconsistent) - Process inputs outside forms (causes excessive API calls) - Use numbers without units ($ for money, months for time) - Forget accessibility (tooltips, clear labels, large touch targets)","title":"10. Key Takeaways for Your Dashboard"}]}